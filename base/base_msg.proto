//
// COPYRIGHT 2017 Brightgate Inc. All rights reserved.
//
// This copyright notice is Copyright Management Information under 17 USC 1202
// and is included to protect this work and deter copyright infringement.
// Removal or alteration of this Copyright Management Information without the
// express written permission of Brightgate Inc is prohibited, and any
// such unauthorized removal or alteration will be a violation of federal law.
//
// vim:set comments=b\://:

// # Field number partitioning
//
// We write field numbers as hexadecimal integer literals, so that the
// partitioning is evident.  So that we might combine the messages into
// a smaller set of unified messages in the future, we partition the
// per-message field numbers into ranges.  (This choice trades off
// message size against later refactoring.) When adding a new message type,
// take the range roughly 100 above the message above.
//
// ## Common field numbers
//
// 0x01  Timestamp for event/message.
// 0x02  Sender string for event/message.
// ...
// 0x0f
//
// # Conventions
// - MAC addresses are the low 6 bytes of a 64-bit fixed integer.
// - IPv4 addresses are a 32-bit fixed integer.

// XXX Debian parser of the moment only recognizes "proto2".  Plan on an
// update.
syntax = "proto2";

package base_msg;

message Timestamp {
	required int64 seconds = 0x01;
	required int32 nanos = 0x02;
}

// XXX In some ways, this enum duplicates content we already have in
// services(5).  But since services mixes TCP, UDP, and RPC with a
// syntax beyond an integer, we will build our own list for now.
enum Protocol {
	DNS = 1;
	DHCP = 2;
}

// The ping message is sent shortly after an application or service
// establishes its publication connection to the broker.  It should be the
// first message sent after connection establishment.
// @topic "sys.ping", TOPIC_PING
// @range 0x100
message EventPing {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	optional string ping_message = 0x100;
}

message MCPRequest {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	enum Operation {
		GET = 1;
		SET = 2;
		DO = 3;
	}
	required Operation operation = 0x140;

	optional int32 state = 0x141;
	optional string command = 0x142;
	optional string daemon = 0x143;
}

message MCPResponse {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	enum OpResponse {
		OP_OK = 0;
		NO_DAEMON = 1;
		INVALID = 99;
	}
	required OpResponse response = 0x180;

	optional string state = 0x181;
}

// The config message is sent whenever an application or service
// modifies shared configuration.  Subscribers--all applications or
// services that have public configuration--must then determine whether or
// not they must modify their operations in response to the updated
// configuration.
// @topic "sys.config", TOPIC_CONFIG
// @range 0x200
message EventConfig {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	enum Type {
		CHANGE = 1;
		DELETE = 2;
		EXPIRE = 3;
	}

	optional Type type = 0x200;
	optional string scope_name = 0x201;
	optional string property = 0x202;
	optional string new_value = 0x203;
}

// XXX sys.error
// @topic "sys.error", TOPIC_ERROR
// @range 0x300

// The network entity message is sent whenever an application or service
// suspects that it has discovered a new or modified entity (IP endpoint)
// on a network, or when it believes that an entity has departed the
// network.
// @topic "net.entity", TOPIC_ENTITY
// @range 0x400
message EventNetEntity {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	optional fixed64 mac_address = 0x400;
	optional fixed32 ipv4_address = 0x401;
	optional string interface_name = 0x402;
	optional string hostname = 0x403;
}

// The network resource is sent whenever an application or service
// allocates or reclaims a resource it manages.  An example managed
// resource would be DHCP lease offers and releases.
// @topic "net.resource", TOPIC_RESOURCE
// @range 0x500
message EventNetResource {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	enum Action {
		RELEASED = 1;
		PROVISIONED = 2;
		CLAIMED = 3;
		COLLISION = 4;
	}

	optional Action action = 0x500;
	optional fixed32 ipv4_address = 0x501;
	optional string hostname = 0x502;
	optional fixed32 duration = 0x503;
	// Who's involved?
}

// The network request is sent whenever an application or service issues
// an information request that does not imply allocation.  An example
// request would be a DNS host lookup.
//
// For DNS, the requestor field is an IP address.  There may be multiple
// requests and responses.
//
// For DHCP, the requestor field is a MAC address.  There is typically
// one request and one response.
//
// @topic "net.request", TOPIC_REQUEST
// @range 0x600
message EventNetRequest {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;
	optional string identity_uuid = 0x04;

	optional Protocol protocol = 0x0600;

	repeated string request = 0x0601;
	repeated string response = 0x0602;

	// protocol-specific requestor
	optional string requestor = 0x0603;
}

// XXX net.service
// @topic "net.service", TOPIC_SERVICE
// @range 0x700

// The network exception is sent whenever an application or service
// detects a request that is not allowed and responds with the reason
// for the disallowance.
// @topic "net.exception", TOPIC_EXCEPTION
// @range 0x800

message EventNetException {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;
	optional string identity_uuid = 0x04;

	optional Protocol protocol = 0x0800;

	enum Reason {
		DIRECT_FORBIDDEN = 1;
		POLICY_BOUNDARY_VIOLATED = 2;
		ILLEGAL_ADDRESS = 3;
	}
	optional Reason reason = 0x801;
	optional string message = 0x802;

	optional string requestor = 0x0803;
}

// The network identity is sent whenever the identifier daemon is able to
// identify a client device.
// @topic "net.identity", TOPIC_IDENTITY
// @range 0x900

message EventNetIdentity {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	optional fixed64 mac_address = 0x900;
	optional string name = 0x901;
	optional double certainty = 0x902;

}

// Configuration messages (0x2000 - 0x20ff)
// XXX Types and lists?
// Delete is not defined without a property name.

message ConfigQuery {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;
	optional string identity_uuid = 0x04;

	// XXX Should we just model on REST?  (GET, POST, PUT, DELETE?)
	enum Operation {
		GET = 1;
		SET = 2;
		CREATE = 3;
		DELETE = 4;
	}
	required Operation operation = 0x2000;

	optional string property = 0x2001;
	optional string value = 0x2002;
	optional Timestamp expires = 0x2003;
}

message ConfigResponse {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;
	optional string identity_uuid = 0x04;

	enum OpResponse {
		OP_OK = 0;
		PROP_NOT_FOUND = 1;
		VALUE_NOT_FOUND = 2;
		NO_PERM = 3;
		UNSUPPORTED = 4;
	}
	required OpResponse response = 0x2003;

	optional string property = 0x2001;
	optional string value = 0x2002;
}

// For network scans
message Port {
	required string protocol = 0x01;
	required int32 port_id = 0x02;
	required string state = 0x03;
	required string state_reason = 0x04;
	required string service_name = 0x05;
	required string service_method = 0x06;
	required int32 confidence = 0x07;
	optional string device_type = 0x08;
	optional string product = 0x09;
	optional string extra_info = 0x0a;
	optional string service_fp = 0x0b;
	optional string version = 0x0c;
	repeated string cpes = 0x0d;
	optional string ostype = 0x0e;
}

// Info for closed|filtered ports
message ExtraPort {
	required string state = 0x01;
	required int32 count = 0x02;
	required string reason = 0x03;
}

// used in OS identification
message UsedPort {
	required string state = 0x01;
	required string protocol = 0x02;
	required int32 port_id = 0x03;
}

message OSMatch {
	required string name = 0x01;
	required string accuracy = 0x02;
	required string line = 0x03;
	repeated OSClass os_classes = 0x04;
}

message OSClass {
	required string type = 0x01;
	required string vendor = 0x02;
	required string osfamily = 0x03;
	required string osgen = 0x04;
	required string accuracy = 0x05;
	repeated string cpes = 0x06;
}

// used for hostnames and addresses
message InfoAndType {
	required string info = 0x01;
	required string type = 0x02;
}

message Host {
	required Timestamp starttime = 0x01;
	required Timestamp endtime = 0x02;
	required string status = 0x03;
	required string status_reason = 0x04;
	repeated InfoAndType addresses = 0x05;
	repeated InfoAndType hostnames = 0x06;
	repeated ExtraPort extra_ports = 0x07;
	repeated Port ports = 0x08;

	repeated UsedPort ports_used = 0x09;
	repeated OSMatch os_matches = 0x0a;
	repeated string os_fingerprints = 0x0b;

	optional int32 uptime = 0x0c;
	optional string lastboot = 0x0d;
}

// Contains information about newest network scan
// @topic "net.scan", TOPIC_SCAN
// @range 0x1000
message EventNetScan {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;
	required string scan_location = 0x1000;
	required string start_info = 0x1001;
	repeated Host hosts = 0x1002;
	required string summary = 0x1003;
}

message Pair {
	required string header = 0x01;
	required string value = 0x02;
}

// Contains information about SSDP
message EventSSDP {
	required string address = 0xb00;

	enum MessageType {
		ALIVE = 0;
		BYEBYE = 1;
		DISCOVER = 2;
	}
	required MessageType type = 0xb01;

	// notify and response
	optional string server = 0xb02;
	optional string unique_service_name = 0xb03;
	optional string location = 0xb04;

	// search and response
	optional string search_target = 0xb05;

	// notify
	optional string notification_type = 0xb06;

	repeated Pair extra_headers = 0xb07;
}

// Contains information about mDNS
message EventmDNS {
	required string address = 0xc00;
	repeated string request = 0xc01;
	repeated string response = 0xc02;
}

// Union of EventSSDP and EventmDNS messages
// @topic "net.listen", TOPIC_LISTEN
message EventListen {
	required Timestamp timestamp = 0x01;
	optional string sender = 0x02;
	optional string debug = 0x03;

	enum Type {
		SSDP = 1;
		mDNS = 2;
	}
	required Type type = 0xa00;

	// Only one of these will be set
	optional EventSSDP ssdp = 0xa01;
	optional EventmDNS mdns = 0xa02;
}
